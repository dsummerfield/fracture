// Generated by gen_vector.py

using System;
using System.Text;

namespace Squared.Util {
    using Elt = Single;

    public interface IComparable2<T> {
        Vec2 CompareTo(T other);
    }

    #region Auto-generated code for struct Vec2

    public partial struct Vec2 : IComparable<Vec2>, IComparable2<Vec2> {
        public Elt X, Y;

        public Vec2 (Elt x, Elt y) {
            X = x;
            Y = y;
        }

        public static Vec2 operator - (Vec2 value) {
            return new Vec2(
                -value.X, -value.Y
            );
        }

        public static Vec2 operator + (Vec2 lhs, Vec2 rhs) {
            return new Vec2(
                lhs.X + rhs.X, lhs.Y + rhs.Y
            );
        }

        public static Vec2 operator + (Vec2 lhs, Elt rhs) {
            return new Vec2(
                lhs.X + rhs, lhs.Y + rhs
            );
        }

        public static Vec2 operator - (Vec2 lhs, Vec2 rhs) {
            return new Vec2(
                lhs.X - rhs.X, lhs.Y - rhs.Y
            );
        }

        public static Vec2 operator - (Vec2 lhs, Elt rhs) {
            return new Vec2(
                lhs.X - rhs, lhs.Y - rhs
            );
        }

        public static Vec2 operator * (Vec2 lhs, Vec2 rhs) {
            return new Vec2(
                lhs.X * rhs.X, lhs.Y * rhs.Y
            );
        }

        public static Vec2 operator * (Vec2 lhs, Elt rhs) {
            return new Vec2(
                lhs.X * rhs, lhs.Y * rhs
            );
        }

        public static Vec2 operator / (Vec2 lhs, Vec2 rhs) {
            return new Vec2(
                lhs.X / rhs.X, lhs.Y / rhs.Y
            );
        }

        public static Vec2 operator / (Vec2 lhs, Elt rhs) {
            return new Vec2(
                lhs.X / rhs, lhs.Y / rhs
            );
        }

        public static bool operator == (Vec2 lhs, Vec2 rhs) {
            return (lhs.X == rhs.X) && (lhs.Y == rhs.Y);
        }

        public static bool operator != (Vec2 lhs, Vec2 rhs) {
            return (lhs.X != rhs.X) || (lhs.Y != rhs.Y);
        }

        public static bool operator < (Vec2 lhs, Vec2 rhs) {
            return (lhs.X < rhs.X) || (lhs.Y < rhs.Y);
        }

        public static bool operator > (Vec2 lhs, Vec2 rhs) {
            return (lhs.X > rhs.X) || (lhs.Y > rhs.Y);
        }

        public override bool Equals (object o) {
            if ((o == null) || (GetType() != o.GetType())) {
                return false;
            } else {
                Vec2 rhs = (Vec2)o;
                return (X == rhs.X) && (Y == rhs.Y);
            }
        }

        public override int GetHashCode () {
            return X.GetHashCode() ^ Y.GetHashCode();
        }

        int IComparable<Vec2>.CompareTo (Vec2 other) {
            int result = 0;
            result = X.CompareTo(other.X);
            if (result != 0) return result;
            result = Y.CompareTo(other.Y);
            if (result != 0) return result;
            return result;
        }

        public Vec2 CompareTo (Vec2 other) {
            return new Vec2(
                X.CompareTo(other.X), Y.CompareTo(other.Y)
            );
        }

        public Elt Magnitude {
            get {
                return (Elt)Math.Sqrt((X * X) + (Y * Y));
            }
        }

        public Vec2 ToUnit() {
            return this / this.Magnitude;
        }

        public Single[] ToArray() {
            return new Single[] { X, Y };
        }

        public override string ToString() {
            return String.Format("({0}, {1})", X, Y);
        }

    }

    #endregion

    public interface IComparable3<T> {
        Vec3 CompareTo(T other);
    }

    #region Auto-generated code for struct Vec3

    public partial struct Vec3 : IComparable<Vec3>, IComparable3<Vec3> {
        public Elt X, Y, Z;

        public Vec3 (Elt x, Elt y, Elt z) {
            X = x;
            Y = y;
            Z = z;
        }

        public static Vec3 operator - (Vec3 value) {
            return new Vec3(
                -value.X, -value.Y, -value.Z
            );
        }

        public static Vec3 operator + (Vec3 lhs, Vec3 rhs) {
            return new Vec3(
                lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z
            );
        }

        public static Vec3 operator + (Vec3 lhs, Elt rhs) {
            return new Vec3(
                lhs.X + rhs, lhs.Y + rhs, lhs.Z + rhs
            );
        }

        public static Vec3 operator - (Vec3 lhs, Vec3 rhs) {
            return new Vec3(
                lhs.X - rhs.X, lhs.Y - rhs.Y, lhs.Z - rhs.Z
            );
        }

        public static Vec3 operator - (Vec3 lhs, Elt rhs) {
            return new Vec3(
                lhs.X - rhs, lhs.Y - rhs, lhs.Z - rhs
            );
        }

        public static Vec3 operator * (Vec3 lhs, Vec3 rhs) {
            return new Vec3(
                lhs.X * rhs.X, lhs.Y * rhs.Y, lhs.Z * rhs.Z
            );
        }

        public static Vec3 operator * (Vec3 lhs, Elt rhs) {
            return new Vec3(
                lhs.X * rhs, lhs.Y * rhs, lhs.Z * rhs
            );
        }

        public static Vec3 operator / (Vec3 lhs, Vec3 rhs) {
            return new Vec3(
                lhs.X / rhs.X, lhs.Y / rhs.Y, lhs.Z / rhs.Z
            );
        }

        public static Vec3 operator / (Vec3 lhs, Elt rhs) {
            return new Vec3(
                lhs.X / rhs, lhs.Y / rhs, lhs.Z / rhs
            );
        }

        public static bool operator == (Vec3 lhs, Vec3 rhs) {
            return (lhs.X == rhs.X) && (lhs.Y == rhs.Y) && (lhs.Z == rhs.Z);
        }

        public static bool operator != (Vec3 lhs, Vec3 rhs) {
            return (lhs.X != rhs.X) || (lhs.Y != rhs.Y) || (lhs.Z != rhs.Z);
        }

        public static bool operator < (Vec3 lhs, Vec3 rhs) {
            return (lhs.X < rhs.X) || (lhs.Y < rhs.Y) || (lhs.Z < rhs.Z);
        }

        public static bool operator > (Vec3 lhs, Vec3 rhs) {
            return (lhs.X > rhs.X) || (lhs.Y > rhs.Y) || (lhs.Z > rhs.Z);
        }

        public override bool Equals (object o) {
            if ((o == null) || (GetType() != o.GetType())) {
                return false;
            } else {
                Vec3 rhs = (Vec3)o;
                return (X == rhs.X) && (Y == rhs.Y) && (Z == rhs.Z);
            }
        }

        public override int GetHashCode () {
            return X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode();
        }

        int IComparable<Vec3>.CompareTo (Vec3 other) {
            int result = 0;
            result = X.CompareTo(other.X);
            if (result != 0) return result;
            result = Y.CompareTo(other.Y);
            if (result != 0) return result;
            result = Z.CompareTo(other.Z);
            if (result != 0) return result;
            return result;
        }

        public Vec3 CompareTo (Vec3 other) {
            return new Vec3(
                X.CompareTo(other.X), Y.CompareTo(other.Y), Z.CompareTo(other.Z)
            );
        }

        public Elt Magnitude {
            get {
                return (Elt)Math.Sqrt((X * X) + (Y * Y) + (Z * Z));
            }
        }

        public Vec3 ToUnit() {
            return this / this.Magnitude;
        }

        public Single[] ToArray() {
            return new Single[] { X, Y, Z };
        }

        public override string ToString() {
            return String.Format("({0}, {1}, {2})", X, Y, Z);
        }

    }

    #endregion

    public interface IComparable4<T> {
        Vec4 CompareTo(T other);
    }

    #region Auto-generated code for struct Vec4

    public partial struct Vec4 : IComparable<Vec4>, IComparable4<Vec4> {
        public Elt X, Y, Z, W;

        public Vec4 (Elt x, Elt y, Elt z, Elt w) {
            X = x;
            Y = y;
            Z = z;
            W = w;
        }

        public static Vec4 operator - (Vec4 value) {
            return new Vec4(
                -value.X, -value.Y, -value.Z, -value.W
            );
        }

        public static Vec4 operator + (Vec4 lhs, Vec4 rhs) {
            return new Vec4(
                lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z, lhs.W + rhs.W
            );
        }

        public static Vec4 operator + (Vec4 lhs, Elt rhs) {
            return new Vec4(
                lhs.X + rhs, lhs.Y + rhs, lhs.Z + rhs, lhs.W + rhs
            );
        }

        public static Vec4 operator - (Vec4 lhs, Vec4 rhs) {
            return new Vec4(
                lhs.X - rhs.X, lhs.Y - rhs.Y, lhs.Z - rhs.Z, lhs.W - rhs.W
            );
        }

        public static Vec4 operator - (Vec4 lhs, Elt rhs) {
            return new Vec4(
                lhs.X - rhs, lhs.Y - rhs, lhs.Z - rhs, lhs.W - rhs
            );
        }

        public static Vec4 operator * (Vec4 lhs, Vec4 rhs) {
            return new Vec4(
                lhs.X * rhs.X, lhs.Y * rhs.Y, lhs.Z * rhs.Z, lhs.W * rhs.W
            );
        }

        public static Vec4 operator * (Vec4 lhs, Elt rhs) {
            return new Vec4(
                lhs.X * rhs, lhs.Y * rhs, lhs.Z * rhs, lhs.W * rhs
            );
        }

        public static Vec4 operator / (Vec4 lhs, Vec4 rhs) {
            return new Vec4(
                lhs.X / rhs.X, lhs.Y / rhs.Y, lhs.Z / rhs.Z, lhs.W / rhs.W
            );
        }

        public static Vec4 operator / (Vec4 lhs, Elt rhs) {
            return new Vec4(
                lhs.X / rhs, lhs.Y / rhs, lhs.Z / rhs, lhs.W / rhs
            );
        }

        public static bool operator == (Vec4 lhs, Vec4 rhs) {
            return (lhs.X == rhs.X) && (lhs.Y == rhs.Y) && (lhs.Z == rhs.Z) && (lhs.W == rhs.W);
        }

        public static bool operator != (Vec4 lhs, Vec4 rhs) {
            return (lhs.X != rhs.X) || (lhs.Y != rhs.Y) || (lhs.Z != rhs.Z) || (lhs.W != rhs.W);
        }

        public static bool operator < (Vec4 lhs, Vec4 rhs) {
            return (lhs.X < rhs.X) || (lhs.Y < rhs.Y) || (lhs.Z < rhs.Z) || (lhs.W < rhs.W);
        }

        public static bool operator > (Vec4 lhs, Vec4 rhs) {
            return (lhs.X > rhs.X) || (lhs.Y > rhs.Y) || (lhs.Z > rhs.Z) || (lhs.W > rhs.W);
        }

        public override bool Equals (object o) {
            if ((o == null) || (GetType() != o.GetType())) {
                return false;
            } else {
                Vec4 rhs = (Vec4)o;
                return (X == rhs.X) && (Y == rhs.Y) && (Z == rhs.Z) && (W == rhs.W);
            }
        }

        public override int GetHashCode () {
            return X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode();
        }

        int IComparable<Vec4>.CompareTo (Vec4 other) {
            int result = 0;
            result = X.CompareTo(other.X);
            if (result != 0) return result;
            result = Y.CompareTo(other.Y);
            if (result != 0) return result;
            result = Z.CompareTo(other.Z);
            if (result != 0) return result;
            result = W.CompareTo(other.W);
            if (result != 0) return result;
            return result;
        }

        public Vec4 CompareTo (Vec4 other) {
            return new Vec4(
                X.CompareTo(other.X), Y.CompareTo(other.Y), Z.CompareTo(other.Z), W.CompareTo(other.W)
            );
        }

        public Elt Magnitude {
            get {
                return (Elt)Math.Sqrt((X * X) + (Y * Y) + (Z * Z) + (W * W));
            }
        }

        public Vec4 ToUnit() {
            return this / this.Magnitude;
        }

        public Single[] ToArray() {
            return new Single[] { X, Y, Z, W };
        }

        public override string ToString() {
            return String.Format("({0}, {1}, {2}, {3})", X, Y, Z, W);
        }

    }

    #endregion

}
