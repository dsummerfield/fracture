// Generated by gen_vector.py

using System;
using System.Text;

namespace Squared.Util {
    using Elt = Single;

    #region Auto-generated code for struct Vec2

    public partial struct Vec2 {
        public Elt X, Y;

        public Vec2 (Elt x, Elt y) {
            X = x;
            Y = y;
        }

        public static Vec2 operator - (Vec2 value) {
            return new Vec2(
                -value.X, -value.Y
            );
        }

        public static Vec2 operator + (Vec2 lhs, Vec2 rhs) {
            return new Vec2(
                lhs.X + rhs.X, lhs.Y + rhs.Y
            );
        }

        public static Vec2 operator + (Vec2 lhs, Elt rhs) {
            return new Vec2(
                lhs.X + rhs, lhs.Y + rhs
            );
        }

        public static Vec2 operator - (Vec2 lhs, Vec2 rhs) {
            return new Vec2(
                lhs.X - rhs.X, lhs.Y - rhs.Y
            );
        }

        public static Vec2 operator - (Vec2 lhs, Elt rhs) {
            return new Vec2(
                lhs.X - rhs, lhs.Y - rhs
            );
        }

        public static Vec2 operator * (Vec2 lhs, Vec2 rhs) {
            return new Vec2(
                lhs.X * rhs.X, lhs.Y * rhs.Y
            );
        }

        public static Vec2 operator * (Vec2 lhs, Elt rhs) {
            return new Vec2(
                lhs.X * rhs, lhs.Y * rhs
            );
        }

        public static Vec2 operator / (Vec2 lhs, Vec2 rhs) {
            return new Vec2(
                lhs.X / rhs.X, lhs.Y / rhs.Y
            );
        }

        public static Vec2 operator / (Vec2 lhs, Elt rhs) {
            return new Vec2(
                lhs.X / rhs, lhs.Y / rhs
            );
        }

        public static bool operator == (Vec2 lhs, Vec2 rhs) {
            return (lhs.X == rhs.X) && (lhs.Y == rhs.Y);
        }

        public static bool operator != (Vec2 lhs, Vec2 rhs) {
            return (lhs.X != rhs.X) || (lhs.Y != rhs.Y);
        }

        public static bool operator < (Vec2 lhs, Vec2 rhs) {
            return (lhs.X < rhs.X) || (lhs.Y < rhs.Y);
        }

        public static bool operator > (Vec2 lhs, Vec2 rhs) {
            return (lhs.X > rhs.X) || (lhs.Y > rhs.Y);
        }

        public Elt Magnitude {
            get {
                return (Elt)Math.Sqrt((X * X) + (Y * Y));
            }
        }

        public Vec2 ToUnit() {
            return this / this.Magnitude;
        }

        public Single[] ToArray() {
            return new Single[] { X, Y };
        }

        public override string ToString() {
            return String.Format("({0}, {1})", X, Y);
        }

    }

    #endregion

    #region Auto-generated code for struct Vec3

    public partial struct Vec3 {
        public Elt X, Y, Z;

        public Vec3 (Elt x, Elt y, Elt z) {
            X = x;
            Y = y;
            Z = z;
        }

        public static Vec3 operator - (Vec3 value) {
            return new Vec3(
                -value.X, -value.Y, -value.Z
            );
        }

        public static Vec3 operator + (Vec3 lhs, Vec3 rhs) {
            return new Vec3(
                lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z
            );
        }

        public static Vec3 operator + (Vec3 lhs, Elt rhs) {
            return new Vec3(
                lhs.X + rhs, lhs.Y + rhs, lhs.Z + rhs
            );
        }

        public static Vec3 operator - (Vec3 lhs, Vec3 rhs) {
            return new Vec3(
                lhs.X - rhs.X, lhs.Y - rhs.Y, lhs.Z - rhs.Z
            );
        }

        public static Vec3 operator - (Vec3 lhs, Elt rhs) {
            return new Vec3(
                lhs.X - rhs, lhs.Y - rhs, lhs.Z - rhs
            );
        }

        public static Vec3 operator * (Vec3 lhs, Vec3 rhs) {
            return new Vec3(
                lhs.X * rhs.X, lhs.Y * rhs.Y, lhs.Z * rhs.Z
            );
        }

        public static Vec3 operator * (Vec3 lhs, Elt rhs) {
            return new Vec3(
                lhs.X * rhs, lhs.Y * rhs, lhs.Z * rhs
            );
        }

        public static Vec3 operator / (Vec3 lhs, Vec3 rhs) {
            return new Vec3(
                lhs.X / rhs.X, lhs.Y / rhs.Y, lhs.Z / rhs.Z
            );
        }

        public static Vec3 operator / (Vec3 lhs, Elt rhs) {
            return new Vec3(
                lhs.X / rhs, lhs.Y / rhs, lhs.Z / rhs
            );
        }

        public static bool operator == (Vec3 lhs, Vec3 rhs) {
            return (lhs.X == rhs.X) && (lhs.Y == rhs.Y) && (lhs.Z == rhs.Z);
        }

        public static bool operator != (Vec3 lhs, Vec3 rhs) {
            return (lhs.X != rhs.X) || (lhs.Y != rhs.Y) || (lhs.Z != rhs.Z);
        }

        public static bool operator < (Vec3 lhs, Vec3 rhs) {
            return (lhs.X < rhs.X) || (lhs.Y < rhs.Y) || (lhs.Z < rhs.Z);
        }

        public static bool operator > (Vec3 lhs, Vec3 rhs) {
            return (lhs.X > rhs.X) || (lhs.Y > rhs.Y) || (lhs.Z > rhs.Z);
        }

        public Elt Magnitude {
            get {
                return (Elt)Math.Sqrt((X * X) + (Y * Y) + (Z * Z));
            }
        }

        public Vec3 ToUnit() {
            return this / this.Magnitude;
        }

        public Single[] ToArray() {
            return new Single[] { X, Y, Z };
        }

        public override string ToString() {
            return String.Format("({0}, {1}, {2})", X, Y, Z);
        }

    }

    #endregion

    #region Auto-generated code for struct Vec4

    public partial struct Vec4 {
        public Elt X, Y, Z, W;

        public Vec4 (Elt x, Elt y, Elt z, Elt w) {
            X = x;
            Y = y;
            Z = z;
            W = w;
        }

        public static Vec4 operator - (Vec4 value) {
            return new Vec4(
                -value.X, -value.Y, -value.Z, -value.W
            );
        }

        public static Vec4 operator + (Vec4 lhs, Vec4 rhs) {
            return new Vec4(
                lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z, lhs.W + rhs.W
            );
        }

        public static Vec4 operator + (Vec4 lhs, Elt rhs) {
            return new Vec4(
                lhs.X + rhs, lhs.Y + rhs, lhs.Z + rhs, lhs.W + rhs
            );
        }

        public static Vec4 operator - (Vec4 lhs, Vec4 rhs) {
            return new Vec4(
                lhs.X - rhs.X, lhs.Y - rhs.Y, lhs.Z - rhs.Z, lhs.W - rhs.W
            );
        }

        public static Vec4 operator - (Vec4 lhs, Elt rhs) {
            return new Vec4(
                lhs.X - rhs, lhs.Y - rhs, lhs.Z - rhs, lhs.W - rhs
            );
        }

        public static Vec4 operator * (Vec4 lhs, Vec4 rhs) {
            return new Vec4(
                lhs.X * rhs.X, lhs.Y * rhs.Y, lhs.Z * rhs.Z, lhs.W * rhs.W
            );
        }

        public static Vec4 operator * (Vec4 lhs, Elt rhs) {
            return new Vec4(
                lhs.X * rhs, lhs.Y * rhs, lhs.Z * rhs, lhs.W * rhs
            );
        }

        public static Vec4 operator / (Vec4 lhs, Vec4 rhs) {
            return new Vec4(
                lhs.X / rhs.X, lhs.Y / rhs.Y, lhs.Z / rhs.Z, lhs.W / rhs.W
            );
        }

        public static Vec4 operator / (Vec4 lhs, Elt rhs) {
            return new Vec4(
                lhs.X / rhs, lhs.Y / rhs, lhs.Z / rhs, lhs.W / rhs
            );
        }

        public static bool operator == (Vec4 lhs, Vec4 rhs) {
            return (lhs.X == rhs.X) && (lhs.Y == rhs.Y) && (lhs.Z == rhs.Z) && (lhs.W == rhs.W);
        }

        public static bool operator != (Vec4 lhs, Vec4 rhs) {
            return (lhs.X != rhs.X) || (lhs.Y != rhs.Y) || (lhs.Z != rhs.Z) || (lhs.W != rhs.W);
        }

        public static bool operator < (Vec4 lhs, Vec4 rhs) {
            return (lhs.X < rhs.X) || (lhs.Y < rhs.Y) || (lhs.Z < rhs.Z) || (lhs.W < rhs.W);
        }

        public static bool operator > (Vec4 lhs, Vec4 rhs) {
            return (lhs.X > rhs.X) || (lhs.Y > rhs.Y) || (lhs.Z > rhs.Z) || (lhs.W > rhs.W);
        }

        public Elt Magnitude {
            get {
                return (Elt)Math.Sqrt((X * X) + (Y * Y) + (Z * Z) + (W * W));
            }
        }

        public Vec4 ToUnit() {
            return this / this.Magnitude;
        }

        public Single[] ToArray() {
            return new Single[] { X, Y, Z, W };
        }

        public override string ToString() {
            return String.Format("({0}, {1}, {2}, {3})", X, Y, Z, W);
        }

    }

    #endregion

}
