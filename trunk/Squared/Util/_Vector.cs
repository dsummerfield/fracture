// Generated by gen_vector.py

using System;
using System.Text;

namespace Squared.Util.Vector {
    using Elt = Single;

    public interface IComparable2<T> {
        Vector2 CompareTo(T other);
    }

    #region Auto-generated code for struct Vector2

    public partial struct Vector2 : IComparable<Vector2>, IComparable2<Vector2> {
        public Elt X, Y;

        public Vector2 (Elt x, Elt y) {
            X = x;
            Y = y;
        }

        public static Vector2 operator - (Vector2 value) {
            return new Vector2(
                -value.X, -value.Y
            );
        }

        public static Vector2 operator + (Vector2 lhs, Vector2 rhs) {
            return new Vector2(
                lhs.X + rhs.X, lhs.Y + rhs.Y
            );
        }

        public static Vector2 operator + (Vector2 lhs, Elt rhs) {
            return new Vector2(
                lhs.X + rhs, lhs.Y + rhs
            );
        }

        public static Vector2 operator - (Vector2 lhs, Vector2 rhs) {
            return new Vector2(
                lhs.X - rhs.X, lhs.Y - rhs.Y
            );
        }

        public static Vector2 operator - (Vector2 lhs, Elt rhs) {
            return new Vector2(
                lhs.X - rhs, lhs.Y - rhs
            );
        }

        public static Vector2 operator * (Vector2 lhs, Vector2 rhs) {
            return new Vector2(
                lhs.X * rhs.X, lhs.Y * rhs.Y
            );
        }

        public static Vector2 operator * (Vector2 lhs, Elt rhs) {
            return new Vector2(
                lhs.X * rhs, lhs.Y * rhs
            );
        }

        public static Vector2 operator / (Vector2 lhs, Vector2 rhs) {
            return new Vector2(
                lhs.X / rhs.X, lhs.Y / rhs.Y
            );
        }

        public static Vector2 operator / (Vector2 lhs, Elt rhs) {
            return new Vector2(
                lhs.X / rhs, lhs.Y / rhs
            );
        }

        public static bool operator == (Vector2 lhs, Vector2 rhs) {
            return (lhs.X == rhs.X) && (lhs.Y == rhs.Y);
        }

        public static bool operator != (Vector2 lhs, Vector2 rhs) {
            return (lhs.X != rhs.X) || (lhs.Y != rhs.Y);
        }

        public static bool operator < (Vector2 lhs, Vector2 rhs) {
            return (lhs.X < rhs.X) || (lhs.Y < rhs.Y);
        }

        public static bool operator > (Vector2 lhs, Vector2 rhs) {
            return (lhs.X > rhs.X) || (lhs.Y > rhs.Y);
        }

        public override bool Equals (object o) {
            if ((o == null) || (GetType() != o.GetType())) {
                return false;
            } else {
                Vector2 rhs = (Vector2)o;
                return (X == rhs.X) && (Y == rhs.Y);
            }
        }

        public override int GetHashCode () {
            return X.GetHashCode() ^ Y.GetHashCode();
        }

        int IComparable<Vector2>.CompareTo (Vector2 other) {
            int result = 0;
            result = X.CompareTo(other.X);
            if (result != 0) return result;
            result = Y.CompareTo(other.Y);
            if (result != 0) return result;
            return result;
        }

        public Vector2 CompareTo (Vector2 other) {
            return new Vector2(
                X.CompareTo(other.X), Y.CompareTo(other.Y)
            );
        }

        public Elt Length() {
            return (Elt)Math.Sqrt((X * X) + (Y * Y));
        }

        public Elt LengthSquared() {
            return (Elt)((X * X) + (Y * Y));
        }

        public Vector2 Normalize() {
            return this / this.Length();
        }

        public Single[] ToArray() {
            return new Single[] { X, Y };
        }

        public override string ToString() {
            return String.Format("({0}, {1})", X, Y);
        }

    }

    #endregion

    public interface IComparable3<T> {
        Vector3 CompareTo(T other);
    }

    #region Auto-generated code for struct Vector3

    public partial struct Vector3 : IComparable<Vector3>, IComparable3<Vector3> {
        public Elt X, Y, Z;

        public Vector3 (Elt x, Elt y, Elt z) {
            X = x;
            Y = y;
            Z = z;
        }

        public static Vector3 operator - (Vector3 value) {
            return new Vector3(
                -value.X, -value.Y, -value.Z
            );
        }

        public static Vector3 operator + (Vector3 lhs, Vector3 rhs) {
            return new Vector3(
                lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z
            );
        }

        public static Vector3 operator + (Vector3 lhs, Elt rhs) {
            return new Vector3(
                lhs.X + rhs, lhs.Y + rhs, lhs.Z + rhs
            );
        }

        public static Vector3 operator - (Vector3 lhs, Vector3 rhs) {
            return new Vector3(
                lhs.X - rhs.X, lhs.Y - rhs.Y, lhs.Z - rhs.Z
            );
        }

        public static Vector3 operator - (Vector3 lhs, Elt rhs) {
            return new Vector3(
                lhs.X - rhs, lhs.Y - rhs, lhs.Z - rhs
            );
        }

        public static Vector3 operator * (Vector3 lhs, Vector3 rhs) {
            return new Vector3(
                lhs.X * rhs.X, lhs.Y * rhs.Y, lhs.Z * rhs.Z
            );
        }

        public static Vector3 operator * (Vector3 lhs, Elt rhs) {
            return new Vector3(
                lhs.X * rhs, lhs.Y * rhs, lhs.Z * rhs
            );
        }

        public static Vector3 operator / (Vector3 lhs, Vector3 rhs) {
            return new Vector3(
                lhs.X / rhs.X, lhs.Y / rhs.Y, lhs.Z / rhs.Z
            );
        }

        public static Vector3 operator / (Vector3 lhs, Elt rhs) {
            return new Vector3(
                lhs.X / rhs, lhs.Y / rhs, lhs.Z / rhs
            );
        }

        public static bool operator == (Vector3 lhs, Vector3 rhs) {
            return (lhs.X == rhs.X) && (lhs.Y == rhs.Y) && (lhs.Z == rhs.Z);
        }

        public static bool operator != (Vector3 lhs, Vector3 rhs) {
            return (lhs.X != rhs.X) || (lhs.Y != rhs.Y) || (lhs.Z != rhs.Z);
        }

        public static bool operator < (Vector3 lhs, Vector3 rhs) {
            return (lhs.X < rhs.X) || (lhs.Y < rhs.Y) || (lhs.Z < rhs.Z);
        }

        public static bool operator > (Vector3 lhs, Vector3 rhs) {
            return (lhs.X > rhs.X) || (lhs.Y > rhs.Y) || (lhs.Z > rhs.Z);
        }

        public override bool Equals (object o) {
            if ((o == null) || (GetType() != o.GetType())) {
                return false;
            } else {
                Vector3 rhs = (Vector3)o;
                return (X == rhs.X) && (Y == rhs.Y) && (Z == rhs.Z);
            }
        }

        public override int GetHashCode () {
            return X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode();
        }

        int IComparable<Vector3>.CompareTo (Vector3 other) {
            int result = 0;
            result = X.CompareTo(other.X);
            if (result != 0) return result;
            result = Y.CompareTo(other.Y);
            if (result != 0) return result;
            result = Z.CompareTo(other.Z);
            if (result != 0) return result;
            return result;
        }

        public Vector3 CompareTo (Vector3 other) {
            return new Vector3(
                X.CompareTo(other.X), Y.CompareTo(other.Y), Z.CompareTo(other.Z)
            );
        }

        public Elt Length() {
            return (Elt)Math.Sqrt((X * X) + (Y * Y) + (Z * Z));
        }

        public Elt LengthSquared() {
            return (Elt)((X * X) + (Y * Y) + (Z * Z));
        }

        public Vector3 Normalize() {
            return this / this.Length();
        }

        public Single[] ToArray() {
            return new Single[] { X, Y, Z };
        }

        public override string ToString() {
            return String.Format("({0}, {1}, {2})", X, Y, Z);
        }

    }

    #endregion

    public interface IComparable4<T> {
        Vector4 CompareTo(T other);
    }

    #region Auto-generated code for struct Vector4

    public partial struct Vector4 : IComparable<Vector4>, IComparable4<Vector4> {
        public Elt X, Y, Z, W;

        public Vector4 (Elt x, Elt y, Elt z, Elt w) {
            X = x;
            Y = y;
            Z = z;
            W = w;
        }

        public static Vector4 operator - (Vector4 value) {
            return new Vector4(
                -value.X, -value.Y, -value.Z, -value.W
            );
        }

        public static Vector4 operator + (Vector4 lhs, Vector4 rhs) {
            return new Vector4(
                lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z, lhs.W + rhs.W
            );
        }

        public static Vector4 operator + (Vector4 lhs, Elt rhs) {
            return new Vector4(
                lhs.X + rhs, lhs.Y + rhs, lhs.Z + rhs, lhs.W + rhs
            );
        }

        public static Vector4 operator - (Vector4 lhs, Vector4 rhs) {
            return new Vector4(
                lhs.X - rhs.X, lhs.Y - rhs.Y, lhs.Z - rhs.Z, lhs.W - rhs.W
            );
        }

        public static Vector4 operator - (Vector4 lhs, Elt rhs) {
            return new Vector4(
                lhs.X - rhs, lhs.Y - rhs, lhs.Z - rhs, lhs.W - rhs
            );
        }

        public static Vector4 operator * (Vector4 lhs, Vector4 rhs) {
            return new Vector4(
                lhs.X * rhs.X, lhs.Y * rhs.Y, lhs.Z * rhs.Z, lhs.W * rhs.W
            );
        }

        public static Vector4 operator * (Vector4 lhs, Elt rhs) {
            return new Vector4(
                lhs.X * rhs, lhs.Y * rhs, lhs.Z * rhs, lhs.W * rhs
            );
        }

        public static Vector4 operator / (Vector4 lhs, Vector4 rhs) {
            return new Vector4(
                lhs.X / rhs.X, lhs.Y / rhs.Y, lhs.Z / rhs.Z, lhs.W / rhs.W
            );
        }

        public static Vector4 operator / (Vector4 lhs, Elt rhs) {
            return new Vector4(
                lhs.X / rhs, lhs.Y / rhs, lhs.Z / rhs, lhs.W / rhs
            );
        }

        public static bool operator == (Vector4 lhs, Vector4 rhs) {
            return (lhs.X == rhs.X) && (lhs.Y == rhs.Y) && (lhs.Z == rhs.Z) && (lhs.W == rhs.W);
        }

        public static bool operator != (Vector4 lhs, Vector4 rhs) {
            return (lhs.X != rhs.X) || (lhs.Y != rhs.Y) || (lhs.Z != rhs.Z) || (lhs.W != rhs.W);
        }

        public static bool operator < (Vector4 lhs, Vector4 rhs) {
            return (lhs.X < rhs.X) || (lhs.Y < rhs.Y) || (lhs.Z < rhs.Z) || (lhs.W < rhs.W);
        }

        public static bool operator > (Vector4 lhs, Vector4 rhs) {
            return (lhs.X > rhs.X) || (lhs.Y > rhs.Y) || (lhs.Z > rhs.Z) || (lhs.W > rhs.W);
        }

        public override bool Equals (object o) {
            if ((o == null) || (GetType() != o.GetType())) {
                return false;
            } else {
                Vector4 rhs = (Vector4)o;
                return (X == rhs.X) && (Y == rhs.Y) && (Z == rhs.Z) && (W == rhs.W);
            }
        }

        public override int GetHashCode () {
            return X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode();
        }

        int IComparable<Vector4>.CompareTo (Vector4 other) {
            int result = 0;
            result = X.CompareTo(other.X);
            if (result != 0) return result;
            result = Y.CompareTo(other.Y);
            if (result != 0) return result;
            result = Z.CompareTo(other.Z);
            if (result != 0) return result;
            result = W.CompareTo(other.W);
            if (result != 0) return result;
            return result;
        }

        public Vector4 CompareTo (Vector4 other) {
            return new Vector4(
                X.CompareTo(other.X), Y.CompareTo(other.Y), Z.CompareTo(other.Z), W.CompareTo(other.W)
            );
        }

        public Elt Length() {
            return (Elt)Math.Sqrt((X * X) + (Y * Y) + (Z * Z) + (W * W));
        }

        public Elt LengthSquared() {
            return (Elt)((X * X) + (Y * Y) + (Z * Z) + (W * W));
        }

        public Vector4 Normalize() {
            return this / this.Length();
        }

        public Single[] ToArray() {
            return new Single[] { X, Y, Z, W };
        }

        public override string ToString() {
            return String.Format("({0}, {1}, {2}, {3})", X, Y, Z, W);
        }

    }

    #endregion

}
